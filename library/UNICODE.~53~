(DEFINE-FILE-INFO READTABLE "INTERLISP" PACKAGE "INTERLISP")(FILECREATED "31-Jul-2020 00:41:21" {DSK}<Users>kaplan>Local>medley3.5>lispcore>library>UNICODE.;53 36383        changes to%:  (VARS UNICODECOMS UNICODEMAPPINGHEADER)                    (FNS WRITE-UNICODE-MAPPING READ-UNICODE-MAPPING MAKE-UNICODE-TRANSLATION-TABLES                          UTF8.OUTCHARFN UTF8.INCCODEFN UTF8.PEEKCCODEFN UTF16BE.OUTCHARFN                          UTF16BE.INCCODEFN UTF16BE.PEEKCCODEFN MAKE-UNICODE-RECODE-TABLES                          MAKE-UNICODE-RECODINGS)                    (MACROS UNICODE.TRANSLATE UNICODE.RECODE)      previous date%: "30-Jul-2020 11:57:18" {DSK}<Users>kaplan>Local>medley3.5>lispcore>library>UNICODE.;37)(PRETTYCOMPRINT UNICODECOMS)(RPAQQ UNICODECOMS       [(COMS               (* ;; "External formats")              (FNS UTF8.OUTCHARFN UTF8.INCCODEFN UTF8.PEEKCCODEFN \UTF8.BACKCHARFN)              (FNS UTF16BE.OUTCHARFN UTF16BE.INCCODEFN UTF16BE.PEEKCCODEFN \UTF16.BACKCHARFN)              (FNS MAKE-UNICODE-FORMATS)              (P (MAKE-UNICODE-FORMATS)))        (COMS               (* ;; "Unicode mapping files")              (FNS READ-UNICODE-MAPPING WRITE-UNICODE-MAPPING)                            (* ;; "Automate dumping of a documentation prefix")              (VARS UNICODEMAPPINGHEADER))        (COMS               (* ;; "Set up translation tables for UTF8 and UTFBE external formats")              (FNS MAKE-UNICODE-TRANSLATION-TABLES)              (DECLARE%: EVAL@COMPILE DONTCOPY (MACROS UNICODE.TRANSLATE))              [DECLARE%: DONTEVAL@LOAD DOCOPY (P (MAKE-UNICODE-TRANSLATION-TABLES (                                                                                 READ-UNICODE-MAPPING                                                                                   'XEROX/XCCS-NOJIS)                                                        '*XCCSTOUNICODE*                                                        '*UNICODETOXCCS*]              (GLOBALVARS *XCCSTOUNICODE* *UNICODETOXCCS*))        (FNS SHOWCHARS)        (ADDVARS (UNICODEDIRECTORIES "{DSK}<Users>kaplan>Local>dict>unicode>"))        (DECLARE%: EVAL@COMPILE DONTCOPY (P (EVAL (SYSRECLOOK1 'EXTERNALFORMAT])(* ;; "External formats")(DEFINEQ(UTF8.OUTCHARFN  [LAMBDA (STREAM CHARCODE RAW)                         (* ; "Edited 30-Jul-2020 14:01 by rmk:")                                                            (* ; "Edited 30-Jan-2020 23:08 by rmk:")    (* ;; "PRINT UTF8 sequence for CHARCODE.  Do not do XCCS to Unicode translation of RAW.")    (CL:UNLESS RAW        (SETQ CHARCODE (UNICODE.TRANSLATE CHARCODE *XCCSTOUNICODE*)))    (IF (ILESSP CHARCODE 128)        THEN (\BOUT STREAM (CL:IF (EQ CHARCODE (CHARCODE EOL))                                   (CHARCODE LF)                                   CHARCODE))      ELSEIF (ILESSP CHARCODE 2048)        THEN                                             (* ; "x800")              (\BOUT STREAM (LOGOR (LLSH 3 6)                                   (LRSH CHARCODE 6)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 0 6)))      ELSEIF (ILESSP CHARCODE 65536)        THEN                                             (* ; "x10000")              (\BOUT STREAM (LOGOR (LLSH 7 5)                                   (LRSH CHARCODE 12)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 6 6)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 0 6)))      ELSEIF (ILESSP CHARCODE 2097152)        THEN                                             (* ; "x200000")              (\BOUT STREAM (LOGOR (LLSH 15 4)                                   (LRSH CHARCODE 18)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 12 6)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 6 6)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 0 6)))      ELSE (ERROR "CHARCODE too big for UTF8" CHARCODE])(UTF8.INCCODEFN  [LAMBDA (STREAM RAW)                                  (* ; "Edited 30-Jul-2020 14:02 by rmk:")    (* ;; "Do not do UNICODE to XCSS translation if RAW.")    (LET (BYTE1 BYTE2 BYTE3 BYTE4 CODE)         (SETQ BYTE1 (\BIN STREAM))         (* ;; "Distinguish on header bytex")         [SETQ CODE (IF (ILESSP BYTE1 128)                        THEN                               (* ;; "Test first:  Ascii is the common case")                              BYTE1                      ELSEIF (IGEQ BYTE1 (LLSH 15 4))                        THEN                             (* ; "4 bytes")                              (SETQ BYTE2 (\BIN STREAM))                              (CL:WHEN (ILESSP BYTE2 128)                                  (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2)))                              (SETQ BYTE3 (\BIN STREAM))                              (CL:WHEN (ILESSP BYTE3 128)                                  (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3)))                              (SETQ BYTE4 (\BIN STREAM))                              (CL:WHEN (ILESSP BYTE4 128)                                  (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3 BYTE4)))                              (LOGOR (LLSH (LOADBYTE BYTE1 0 3)                                           18)                                     (LLSH (LOADBYTE BYTE2 0 6)                                           12)                                     (LLSH (LOADBYTE BYTE3 0 6)                                           6)                                     (LOADBYTE BYTE4 0 6))                      ELSEIF (IGEQ BYTE1 (LLSH 7 5))                        THEN                             (* ; "3 bytes")                              (SETQ BYTE2 (\BIN STREAM))                              (CL:WHEN (ILESSP BYTE2 128)                                  (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2)))                              (SETQ BYTE3 (\BIN STREAM))                              (CL:WHEN (ILESSP BYTE3 128)                                  (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3)))                              (LOGOR (LLSH (LOADBYTE BYTE1 0 4)                                           12)                                     (LLSH (LOADBYTE BYTE2 0 6)                                           6)                                     (LOADBYTE BYTE3 0 6))                      ELSE                               (* ; "Must be 2 bytes")                            (SETQ BYTE2 (\BIN STREAM))                            (CL:WHEN (ILESSP BYTE2 128)                                (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2)))                            (LOGOR (LLSH (LOADBYTE BYTE1 0 5)                                         6)                                   (LOADBYTE BYTE2 0 6]         (IF RAW             THEN CODE           ELSE (UNICODE.TRANSLATE CODE *UNICODETOXCCS*])(UTF8.PEEKCCODEFN  [LAMBDA (STREAM NOERROR COUNTP RAW)                   (* ; "Edited 30-Jul-2020 14:05 by rmk:")    (* ;; "Modeled this after \EUCPEEK on LLREAD.  In the multi-byte (non-ASCII) case, backs the file pointer to the beginning by the proper number of \BACKFILEPTRs, and returns a count of 0.  Returns NIL if NOERROR and either invalid UTF8 or end of file.")    (* ;; "Could be that the caller takes care of backing up the file position if the number of binned-bytes is returned.")    (* ;; "Do not do UNICODE to XCCS translation if RAW")    (PROG (BYTE1 BYTE2 BYTE3 BYTE4 CODE)          (SETQ BYTE1 (\PEEKBIN STREAM NOERROR))     (* ;; "Distinguish on header bytex")          (CL:UNLESS BYTE1              (RETURN (AND COUNTP (CL:VALUES NIL 0))))          [IF (ILESSP BYTE1 128)              THEN                     (* ;;                   "Test first:  Ascii is the common case.  No need to back up, since we peeked.")                    (SETQ CODE BYTE1)            ELSEIF (IGEQ BYTE1 (LLSH 15 4))              THEN                                       (* ; "4 bytes")                    (\BIN STREAM)                    (CL:UNLESS (AND (SETQ BYTE2 (\PEEKBIN STREAM NOERROR))                                    (IGEQ BYTE2 128))                        (\BACKFILEPTR STREAM)                        (OR NOERROR (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2)))                        (RETURN (IF COUNTP                                    THEN (CL:VALUES CODE 0)                                  ELSE CODE)))                    (\BIN STREAM)                    (CL:UNLESS (AND (SETQ BYTE3 (\PEEKBIN STREAM NOERROR))                                    (IGEQ BYTE3 128))                        (\BACKFILEPTR STREAM)                        (\BACKFILEPTR STREAM)                        (OR NOERROR (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3)))                        (RETURN (IF COUNTP                                    THEN (CL:VALUES CODE 0)                                  ELSE CODE)))                    (\BIN STREAM)                    (SETQ BYTE4 (\PEEKBIN STREAM NOERROR))   (* ;                                                            "PEEK the last, no need to back it up")                    (\BACKFILEPTR STREAM)                    (\BACKFILEPTR STREAM)                    (\BACKFILEPTR STREAM)                    (IF (AND BYTE4 (IGEQ BYTE4 128))                        THEN (SETQ CODE (LOGOR (LLSH (LOADBYTE BYTE1 0 3)                                                         18)                                                   (LLSH (LOADBYTE BYTE2 0 6)                                                         12)                                                   (LLSH (LOADBYTE BYTE3 0 6)                                                         6)                                                   (LOADBYTE BYTE4 0 6)))                      ELSEIF NOERROR                      ELSE (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3 BYTE4)))            ELSEIF (IGEQ BYTE1 (LLSH 7 5))              THEN                                       (* ; "3 bytes")                    (\BIN STREAM)                    (CL:UNLESS (AND (SETQ BYTE2 (\PEEKBIN STREAM NOERROR))                                    (IGEQ BYTE2 128))                        (\BACKFILEPTR STREAM)                        (OR NOERROR (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2)))                        (RETURN (IF COUNTP                                    THEN (CL:VALUES CODE 0)                                  ELSE CODE)))                    (\BIN STREAM)                    (SETQ BYTE3 (\PEEKBIN STREAM NOERROR))                    (\BACKFILEPTR STREAM)                    (\BACKFILEPTR STREAM)                    (IF (AND BYTE3 (IGEQ BYTE3 128))                        THEN (SETQ CODE (LOGOR (LLSH (LOADBYTE BYTE1 0 4)                                                         12)                                                   (LLSH (LOADBYTE BYTE2 0 6)                                                         6)                                                   (LOADBYTE BYTE3 0 6)))                      ELSEIF NOERROR                      ELSE (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3)))            ELSE                                         (* ; "Must be 2 bytes")                  (\BIN STREAM)                  (SETQ BYTE2 (\PEEKBIN STREAM NOERROR))                  (\BACKFILEPTR STREAM)                  (IF (AND BYTE2 (IGEQ BYTE2 128))                      THEN (SETQ CODE (LOGOR (LLSH (LOADBYTE BYTE1 0 5)                                                       6)                                                 (LOADBYTE BYTE2 0 6)))                    ELSEIF NOERROR                    ELSE (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2]          (CL:WHEN (AND CODE (NOT RAW))              (SETQ CODE (UNICODE.TRANSLATE CODE *UNICODETOXCCS*)))          (RETURN (IF COUNTP                      THEN (CL:VALUES CODE 0)                    ELSE CODE])(\UTF8.BACKCHARFN  [LAMBDA (STREAM COUNTP)                               (* ; "Edited 26-Jul-2020 10:41 by rmk:")    (* ;; "\BACKFILEPTR is NIL at beginning of FILE, just return COUNT")    (BIND (C _ 0) WHILE (CL:WHEN (\BACKFILEPTR STREAM)                                    (ADD C 1)                                    (EQ 2 (LRSH (\PEEKBIN STREAM)                                                6))) REPEATUNTIL (EQ C 4)       FINALLY (RETURN (AND COUNTP C]))(DEFINEQ(UTF16BE.OUTCHARFN  [LAMBDA (STREAM CHARCODE RAW)                         (* ; "Edited 30-Jul-2020 14:03 by rmk:")                                                            (* ; "Edited 30-Jan-2020 23:08 by rmk:")    (* ;; "PRINT UTF16 sequence for CHARCODE.  Do not do XCCS to UNICODE translation if RAW.")    (CL:UNLESS RAW        (SETQ CODE (UNICODE.TRANSLATE CODE *XCCSTOUNICODE*)))    (\BOUT STREAM (LRSH CHARCODE 8))    (\BOUT STREAM (LOGAND CHARCODE 255])(UTF16BE.INCCODEFN  [LAMBDA (STREAM RAW)                                  (* ; "Edited 30-Jul-2020 14:03 by rmk:")    (* ;; "Do not do UNICODE to XCCS translation if RAW")    (LET [(CODE (LOGOR (LLSH (\BIN STREAM)                             8)                       (\BIN STREAM]         (CL:UNLESS RAW (UNICODE.TRANSLATE CODE *UNICODETOXCCS*])(UTF16BE.PEEKCCODEFN  [LAMBDA (STREAM NOERROR COUNTP RAW)                   (* ; "Edited 30-Jul-2020 14:06 by rmk:")    (* ;; "Could be that the caller takes care of backing up the file position if the number of binned-bytes is returned.")    (* ;; "Do not do UNICODE to XCCS translation if RAW")    (LET (BYTE1 BYTE2 CODE)         (SETQ BYTE1 (\PEEKBIN STREAM NOERROR))         (IF BYTE1             THEN (\BIN STREAM)                   (SETQ BYTE2 (\PEEKBIN STREAM NOERROR))                   (\BACKFILEPTR STREAM)                   (IF BYTE2                       THEN (SETQ CODE (LOGOR (LLSH BYTE1 8)                                                  BYTE2))                             (CL:IF COUNTP                                 (CL:VALUES (CL:IF RAW                                                CODE                                                (UNICODE.TRANSLATE CODE *UNICODETOXCCS*))                                        0))                     ELSEIF NOERROR                     ELSE (AND COUNTP (CL:VALUES NIL 0)))           ELSEIF NOERROR             THEN (AND COUNTP (CL:VALUES NIL 0))           ELSE (ERROR "INVALID UTF16 CHARACTER" (LIST BYTE1 BYTE2])(\UTF16.BACKCHARFN  [LAMBDA (STREAM COUNTP)                               (* ; "Edited 26-Jul-2020 13:05 by rmk:")    (* ;; "\BACKFILEPTR is NIL at beginning of FILE, just return COUNT.")    (* ;; "Common for big-ending and little-ending")    (IF (NOT (\BACKFILEPTR STREAM))        THEN (AND COUNTP 0)      ELSEIF (\BACKFILEPTR STREAM)        THEN (AND COUNTP 2)      ELSE (AND COUNTP 1]))(DEFINEQ(MAKE-UNICODE-FORMATS  [LAMBDA NIL                                           (* ; "Edited 29-Jul-2020 08:49 by rmk:")    (* ;; "RAW formats do not do XCCS/Unicode translation, just deal with the byte encoding.")    (\INSTALL.EXTERNALFORMAT :UTF16BE (CREATE EXTERNALFORMAT                                             INCCODEFN _ (FUNCTION UTF16BE.INCCODEFN)                                             PEEKCCODEFN _ (FUNCTION UTF16BE.PEEKCCODEFN)                                             BACKCHARFN _ (FUNCTION \UTF16.BACKCHARFN)                                             FILEOUTCHARFN _ (FUNCTION UTF16BE.OUTCHARFN)))    [\INSTALL.EXTERNALFORMAT :UTF16BE-RAW (CREATE EXTERNALFORMAT                                                 INCCODEFN _ [FUNCTION (LAMBDA (STREAM)                                                                         (UTF16BE.INCCODEFN                                                                          STREAM T]                                                 PEEKCCODEFN _ [FUNCTION (LAMBDA (STREAM NOERROR                                                                                         COUNTP)                                                                           (UTF16BE.PEEKCCODEFN                                                                            STREAM NOERROR COUNTP T]                                                 BACKCHARFN _ (FUNCTION \UTF16.BACKCHARFN)                                                 FILEOUTCHARFN _ (FUNCTION (LAMBDA (STREAM CHARCODE)                                                                             (UTF16BE.OUTCHARFN                                                                              STREAM CHARCODE T]    [\INSTALL.EXTERNALFORMAT :UTF8-RAW (CREATE EXTERNALFORMAT                                              INCCODEFN _ [FUNCTION (LAMBDA (STREAM)                                                                      (UTF8.INCCODEFN STREAM T]                                              PEEKCCODEFN _ [FUNCTION (LAMBDA (STREAM NOERROR COUNTP)                                                                        (UTF8.PEEKCCODEFN STREAM                                                                               NOERROR COUNTP T]                                              BACKCHARFN _ (FUNCTION \UTF8.BACKCHARFN)                                              FILEOUTCHARFN _ (FUNCTION (LAMBDA (STREAM CHARCODE)                                                                          (UTF8.OUTCHARFN STREAM                                                                                 CHARCODE T]    (\INSTALL.EXTERNALFORMAT :UTF8 (CREATE EXTERNALFORMAT                                          INCCODEFN _ (FUNCTION UTF8.INCCODEFN)                                          PEEKCCODEFN _ (FUNCTION UTF8.PEEKCCODEFN)                                          BACKCHARFN _ (FUNCTION \UTF8.BACKCHARFN)                                          FILEOUTCHARFN _ (FUNCTION UTF8.OUTCHARFN]))(MAKE-UNICODE-FORMATS)(* ;; "Unicode mapping files")(DEFINEQ(READ-UNICODE-MAPPING  [LAMBDA (FILE NOPRINT NOERROR)                        (* ; "Edited 30-Jul-2020 19:06 by rmk:")    (* ;; "Reads a char-mapping table from a file coded in the Uncode-CDROM format.  Comments prefixed by # and")    (* ;; "               Column 1:  Input hex code in the format %"0xXXXX%" (fromcode)")    (* ;; "               Column 2:  Corresponding Unicode code in the format %"0xXXXX%" (tocode)")    (* ;; "               Column 3:  (after #) Character name in some mapping files, utf-8 character and XCCS octal code for XCCS mapping files")    (* ;; "")    (* ;; "Result is a list of (fromcode tocode) integer pairs, where pairs are suppress where fromcode and tocode are the same, since the absence of a pair indicates identity.")    (CL:WITH-OPEN-FILE (STREAM (FINDFILE (PACKFILENAME 'BODY FILE 'EXTENSION 'TXT)                                      T UNICODEDIRECTORIES)                              :DIRECTION :INPUT :EXTERNAL-FORMAT :UTF8-RAW)           (BIND FROMCODE TOCODE AFTERFROM LINE [WSBITTABLE _ (MAKEBITTABLE (CHARCODE                                                                                 (TAB SPACE]                  [CBITTABLE _ (MAKEBITTABLE (CHARCODE (TAB SPACE %#]              FIRST (CL:UNLESS (FILEPOS "Name:" STREAM NIL NIL NIL T)                            (ERROR "NOT A UNICODE MAPPING FILE" (FULLNAME STREAM)))                    (CL:UNLESS NOPRINT                        (PRINTOUT T T "Unicode mapping:  " (CL:STRING-TRIM " " (CL:READ-LINE STREAM                                                                                       NIL NIL))                               T)) WHILE (SETQ LINE (CL:READ-LINE STREAM NIL NIL))              UNLESS (OR [EQ (CHARCODE %#)                                 (CHCON1 (SETQ LINE (CL:STRING-LEFT-TRIM " " LINE]                             (EQ 0 (NCHARS LINE)))              COLLECT (SETQ AFTERFROM (STRPOSL WSBITTABLE LINE))                    [SETQ FROMCODE (CHARCODE.DECODE (SUBSTRING LINE 1 (SUB1 AFTERFROM)                                                           (CONSTANT (CONCAT]                    [SETQ LINE (CL:STRING-LEFT-TRIM '(#\Space #\Tab)                                      (SUBSTRING LINE AFTERFROM NIL (CONSTANT (CONCAT]                    [SETQ TOCODE (CHARCODE.DECODE (SUBSTRING LINE 1 [SUB1 (OR (STRPOSL CBITTABLE LINE                                                                                     )                                                                              (ADD1 (NCHARS LINE]                                                         NIL                                                         (CONSTANT (CONCAT]                    (LIST FROMCODE TOCODE])(WRITE-UNICODE-MAPPING  [LAMBDA (MAPPING FILE FROMMERGED)                     (* ; "Edited 30-Jul-2020 23:06 by rmk:")    (* ;; "Writes a symbol unicode mapping file.  If FROMMERGED, the input is in the format that READMERGED and PRINTMERGED use.  Otherwise it is in the format of READ-UNICODE-MAPPING, a simple list of (XCCS-code UNICODE) pairs.")    (CL:WITH-OPEN-FILE (STREAM (PACKFILENAME 'BODY FILE 'DIRECTORY (CAR UNICODEDIRECTORIES)                                      'EXTENSION                                      'TXT)                              :DIRECTION :OUTPUT :IF-EXISTS :NEW-VERSION :EXTERNAL-FORMAT :UTF8-RAW)           (FOR LINE IN UNICODE-MAPPING-HEADER DO (PRINTOUT STREAM "#" 2 LINE T))           (TERPRI STREAM)           (IF FROMMERGED               THEN (FOR CSET IN MAPPING                           DO (PRINTOUT STREAM T "#  " .P2 (CAR CSET)                                         T)                                  (* ;;                     "If Unicode character is NIL, then this is not a defined XCCS character.  Skip")                                 (FOR C IN (CDR CSET) WHEN (CADR C)                                    UNLESS (EQ 'XX (CADR C))                                    DO (PRINTOUT STREAM "0x" (CL:FORMAT NIL "~4,'0X"                                                                        (CHARCODE.DECODE (CAR C)))                                                  "	" "0x" (CADDR C)                                                  "	#  "                                                  (CHARACTER (CHARCODE.DECODE (CADDR C)))                                                  T))                                 (TERPRI STREAM))             ELSE (SORT MAPPING T)                   (FOR M CSET LEFTC RIGHTC IN MAPPING                      DO (SETQ LEFTC (CAR M))                            (SETQ RIGHTC (CADR M))                            (CL:UNLESS (EQ CSET (LRSH LEFTC 8))                                (SETQ CSET (LRSH LEFTC 8))                                (PRINTOUT STREAM T "#  " .P2 (CL:FORMAT NIL "~O" CSET)                                       T))                            (PRINTOUT STREAM "0x" (CL:FORMAT NIL "~4,'0X" LEFTC)                                   "	" "0x" (CL:FORMAT NIL "~4,'0X" RIGHTC)                                   "	#  "                                   (CHARACTER RIGHTC)                                   T)))           (FULLNAME STREAM]))(* ;; "Automate dumping of a documentation prefix")(RPAQQ UNICODEMAPPINGHEADER       ("" "        Name:             XCCS (XC-3-1-1-0) to Unicode" "        Unicode version:  3.0"            "        Table version:    0.1" "        Table format:     Format A"            "        Date:             28 July 2020"            "        Author:           Ron Kaplan <Ron.Kaplan@post.harvard.edu>" ""            "This file contains mappings from the Xerox Character Code Standard (version "            "XC1-3-3-0, 1987) into Unicode 3.0. standard codes.  That is the version of "            "XCCS corresponding to the fonts in the Medley system.  The Xerox mappings"            "did not come from the Unicode CDROM, they were constructed by combining"            "and constrasting information from a binary file (xerox>XCCStoUni)"            "of unknown provenance with code mappings scraped from the Wikipedia page "            "      https://en.wikipedia.org/wiki/Xerox_Character_Code_Standard"            "in July 2020.  Both sources were errorful and incomplete, so the original"            "data was inspected and modified by hand. The data here may be the currently"            "best specification of these mapping, but the mappings may still contain"            "errors--no guarantees.  Obviously, the reverse mappings from Unicode to"            "XCCS are by definition incomplete." ""            "The file XCCS-NOJIS.TXT excludes the large set of mappings for"            "Japanese characters, it just includes characters thatt are more broadly useful." ""            "The JIS mappings are contained in the separate XCCS-JIS.TXT file."            "The full set of mappings can be creating by appending these two files." ""            "The format of this file conforms to the format of the other Unicode-supplied"            "mapping files:" "   Three white-space (tab or spaces) separated columns"            "     Column #1 is the XCCS code (as hex 0xXXXX)"            "     Column #2 is the corresponding Unicode (as hex 0xXXXX)"            "     Column #3 (after #) is a comment column. For convenience, it contains the"            "        Unicode character itself (since the Unicode character names"            "        are not available)"            "Like the other Unicode mapping files, this file can be read by"            "common Unicode routines. Also, itis encoded in UTF8, so that the Unicode characters "            "are properly displayed on the right sideand can be edited by standard "            "Unicode-enabled editors (e.g. Mac Textedit)." ""            "This file and the other Unicode mapping files can also be read by the function"            "READ-UNICODE-MAPPING in the UNICODE Medley library package." ""            "The entries are in XCCS order, and grouped by character sets.  In front of "            "each character set, for convenience, there is a line with the octal XCCS"            "character set, after #." ""            "Note that a given XCCS code might map to codes in several different Unicode"            "positions, sincethere are repetions in the Unicode standard." ""            "Any comments or problems, contact <ron.kaplan@post.harvard.edu>"))(* ;; "Set up translation tables for UTF8 and UTFBE external formats")(DEFINEQ(MAKE-UNICODE-TRANSLATION-TABLES  [LAMBDA (MAPPING LTORVAR RTOLVAR)                     (* ; "Edited 30-Jul-2020 21:15 by rmk:")    (* ;; "MAPPING is the list of numeric code correspondence pairs constructed by applying READ-UNICODE-MAPPING to a Unicode mapping file.")    (* ;; "This produces two recoding arrays, one maps left-side codes into right-side codes (e.g. XCCS or ISO8859-1 to Unicode), for printing, the other maps right-side (Unicode) codes to corresponding right-side codes (e.g. XCCS).")    (* ;; "")    (* ;; "We assume that the left-to-right mapping into Unicode is functional, so that each left code maps to a unique right (Unicode) code, because Unicode is presumably the most refined coding scheme.  But several Unicode codes may map to the same left code, for logically different codes that happen to have the same glyphs. In that case the heuristic is to map each %"from%" code to the lowest of the possible %"to%" codes. This means that round-trip reading/writing or writing/reading from one or both starting points may not always be lossless.")    (* ;; " ")    (* ;; " Each recoding array has 256 elements, one for each possible high-order byte of a character code.  An array entry is either NIL, a 256-array of codes indexed by low-order bytes, or an alist of (lower-order-bytes . codes).  The latter is used to save space for sparsely populated character sets.")    (* ;; "")    (* ;; "The absence of a recoding (NIL) is treated as an identity.")    (* ;; "")    (* ;; "For the convenience of not having to deal with the multiple values, if LTORVAR or RTOLVAR are given, they are set to the constructed arrays before return.")    (LET ((LTORARRAY (CL:MAKE-ARRAY 256 :INITIAL-ELEMENT NIL))          (RTOLARRAY (CL:MAKE-ARRAY 256 :INITIAL-ELEMENT NIL)))         (* ;; "The left-to-right direction (into Unicode).    We start by distributing the mappings into alists in arrays indexed by the higher-order (charaset set byte).  The second loop converts long alists into arrays.")         [FOR PAIR LEFTC RIGHTC IN MAPPING UNLESS (EQ (SETQ LEFTC (CAR PAIR))                                                                  (SETQ RIGHTC (CADR PAIR)))            DO (CL:PUSH (CONS (LOGAND LEFTC 255)                                  RIGHTC)                          (CL:SVREF LTORARRAY (LRSH LEFTC 8]         (FOR I CSA FROM 0 TO 255 WHEN (IGREATERP (LENGTH (CL:SVREF LTORARRAY I))                                                              20)            DO                   (* ;; "Leave it alone if the alist is short")                  (SETQ CSA (CL:MAKE-ARRAY 256 :INITIAL-ELEMENT NIL))                  (FOR P IN (CL:SVREF LTORARRAY I)                     DO (CL:SETF (CL:SVREF CSA (LOGAND (CAR P)                                                          255))                                   (CDR P)))                   (* ;; "Fill in the identities in the array case--avoid an extra NIL test in translating, and allows for identity testing below")                  (FOR J FROM 0 TO 255 UNLESS (CL:SVREF CSA J)                     DO (CL:SETF (CL:SVREF CSA J)                                   (LOGOR (LLSH I 8)                                          J)))                  (CL:SETF (CL:SVREF LTORARRAY I)                         CSA))         (* ;; "")         (* ;; "Now the right-to-left direction (from Unicode). Here we have to detect and compensate for ambiguity.")         (* ;;  "Thus, we don't suppress identities in the alist, so that the PREV test below is always complete.")         (FOR PAIR LEFTC RIGHTC PREV IN MAPPING            DO (SETQ LEFTC (CAR PAIR))                  (SETQ RIGHTC (CADR PAIR))                   (* ;; "Have we already seen an explicit mapping from right to left?")                  [SETQ PREV (ASSOC (LOGAND RIGHTC 255)                                    (CL:SVREF RTOLARRAY (LRSH RIGHTC 8]                  (IF (NULL PREV)                      THEN (CL:PUSH (CONS (LOGAND RIGHTC 255)                                              LEFTC)                                      (CL:SVREF RTOLARRAY (LRSH RIGHTC 8)))                    ELSEIF (IGREATERP (CDR PREV)                                      LEFTC)                      THEN (RPLACD PREV LEFTC)))         (* ;; "Since we didn't suppress identities before, and we still want to conserve a little storage, we have to count the number of non-identities here")         [FOR I CSA FROM 0 TO 255            DO (IF (FOR P (CNT _ 1) IN (CL:SVREF RTOLARRAY I)                              UNLESS (EQ (CAR P)                                             (CDR P)) DO (ADD CNT 1)                                                            (CL:WHEN (EQ CNT 20)                                                                   (RETURN T)))                       THEN (SETQ CSA (CL:MAKE-ARRAY 256 :INITIAL-ELEMENT NIL))                             (FOR P IN (CL:SVREF RTOLARRAY I)                                DO (CL:SETF (CL:SVREF CSA (LOGAND (CAR P)                                                                     255))                                              (CDR P)))                             (FOR J FROM 0 TO 255 UNLESS (CL:SVREF CSA J)                                DO (CL:SETF (CL:SVREF CSA J)                                              (LOGOR (LLSH I 8)                                                     J)))                             (CL:SETF (CL:SVREF RTOLARRAY I)                                    CSA)                     ELSE                            (* ;; "Shrink the alist to nonidentities")                           (CL:SETF (CL:SVREF RTOLARRAY I)                                  (FOR P IN (CL:SVREF RTOLARRAY I)                                     UNLESS (EQ (CAR P)                                                    (CDR P)) COLLECT P]         (CL:WHEN LTORVAR (SETATOMVAL LTORVAR LTORARRAY))         (CL:WHEN RTOLVAR (SETATOMVAL RTOLVAR RTOLARRAY))         (CL:VALUES LTORARRAY RTOLARRAY]))(DECLARE%: EVAL@COMPILE DONTCOPY (DECLARE%: EVAL@COMPILE (PUTPROPS UNICODE.TRANSLATE MACRO [OPENLAMBDA (CODE TRANSLATION-TABLE)                                            (LET [(X (CL:SVREF TRANSLATION-TABLE (LRSH CODE 8]                                                 (COND                                                    ((LISTP X)                                                     (OR (CDR (FASSOC (LOGAND CODE 255)                                                                     X))                                                         CODE))                                                    (T (CL:SVREF X (LOGAND CODE 255])))(DECLARE%: DONTEVAL@LOAD DOCOPY (MAKE-UNICODE-TRANSLATION-TABLES (READ-UNICODE-MAPPING 'XEROX/XCCS-NOJIS)       '*XCCSTOUNICODE*       '*UNICODETOXCCS*))(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS *XCCSTOUNICODE* *UNICODETOXCCS*))(DEFINEQ(SHOWCHARS  [LAMBDA (FROMCHAR TOCHAR FONT)                        (* ; "Edited 26-Jul-2020 17:58 by rmk:")    (RESETFORM (DSPFONT (OR FONT '(CLASSIC 12))                      T)           (CL:WHEN (AND (SMALLP FROMCHAR)                         (NOT TOCHAR))               (* ;;     "If a small number, assume it's an octal (in decimal) character set, no need for string quotes")               (SETQ TOCHAR (CONCAT FROMCHAR "," 376))               (SETQ FROMCHAR (CONCAT FROMCHAR "," 41)))           (CL:UNLESS (SMALLP FROMCHAR)               (SETQ FROMCHAR (CHARCODE.DECODE FROMCHAR)))           (CL:UNLESS (SMALLP TOCHAR)               (SETQ TOCHAR (CL:IF TOCHAR                                (CHARCODE.DECODE TOCHAR)                                FROMCHAR)))           (FOR C FROM FROMCHAR TO TOCHAR UNLESS (AND (IGEQ (LOGAND C 255)                                                                            127)                                                                      (ILEQ (LOGAND C 255)                                                                            (PLUS 128 33)))              DO (PRINTOUT T .P2 (CHARCODESTRING C)                            10                            (CHARACTER C)                            T]))(ADDTOVAR UNICODEDIRECTORIES "{DSK}<Users>kaplan>Local>dict>unicode>")(DECLARE%: EVAL@COMPILE DONTCOPY (EVAL (SYSRECLOOK1 'EXTERNALFORMAT)))(DECLARE%: DONTCOPY  (FILEMAP (NIL (2324 13166 (UTF8.OUTCHARFN 2334 . 4325) (UTF8.INCCODEFN 4327 . 7377) (UTF8.PEEKCCODEFN 7379 . 12657) (\UTF8.BACKCHARFN 12659 . 13164)) (13167 15744 (UTF16BE.OUTCHARFN 13177 . 13673) (UTF16BE.INCCODEFN 13675 . 14044) (UTF16BE.PEEKCCODEFN 14046 . 15301) (\UTF16.BACKCHARFN 15303 . 15742)) (15745 18853 (MAKE-UNICODE-FORMATS 15755 . 18851)) (18921 24291 (READ-UNICODE-MAPPING 18931 . 21727) (WRITE-UNICODE-MAPPING 21729 . 24289)) (27617 33965 (MAKE-UNICODE-TRANSLATION-TABLES 27627 . 33963)) (34883 36210 (SHOWCHARS 34893 . 36208)))))STOP